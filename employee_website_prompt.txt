TELEGRAM MINI APP — CODE-GENERATOR PROMPT

Target: Vite + React + TypeScript (mobile-first)
Purpose: Field staff (employees) — clock-in/out, view shift, payroll, incidents, assets, panic.
Backend: Laravel 12 + PostgreSQL 16 (API endpoints per backend summary).
Deploy: Host on secure HTTPS URL (can be served from cPanel or VPS). Bot will open this URL as “mini app”.

Top-level instructions for the generator

Generate a complete Vite + React + TypeScript repository with production-quality code implementing the Mini App described below. The app must be:

Mobile-first (primary UX), responsive for tablet & desktop.

Accessible (WCAG AA) with keyboard navigation and clear ARIA labels.

Offline-capable: allow offline clock-ins and sync later via IndexedDB + service worker.

Secure: JWT-based auth with secure token handling and refresh flow (see details).

Bilingual: English + Amharic (i18next skeleton).

Tested: Unit tests (Jest + RTL), E2E (Cypress) with core flows mocked.

Documented: README with dev setup (Windows 11 WSL2 + Docker optional), deploy steps, and acceptance TASKS.md.

Do not include unrelated admin pages — this is only the employee mini app UX.

Features & UI flows (must implement)
1. Authentication (phone + password, persisted)

Endpoint: POST /api/auth/login → body { phone, password }.

On success backend returns { access_token, refresh_token, expires_in, user }.

Persistence:

Store refresh_token in HttpOnly Secure cookie if backend supports it (preferred).

Also persist minimal auth state in localForage (IndexedDB) for offline resume; store only a short-lived encrypted token or flag and use refresh token server-side for new access tokens.

Implement "remember me" behavior: user stays logged in on app reopen without retyping password.

Token flow:

Implement axios interceptor to attach Authorization: Bearer <access_token>.

Implement refresh token auto-refresh when access token expires.

Fallback: if refresh fails, show login screen.

2. Mobile-first Home / Shift screen (big clear actionable UI)

Show today’s shift (site name, start/end, role).

Large central CLOCK IN / CLOCK OUT button (big, high-contrast).

Show small map preview of site with radius circle and user pin.

Show distance (meters) live computed client-side.

Show status: Online / Offline, GPS permission status.

If user clicks Clock In:

Request geolocation permission (with explanations).

Capture geolocation (lat, lng, accuracy, timestamp).

Optionally capture a selfie (user chooses).

Send POST /api/attendance/clock-in with { schedule_id, latitude, longitude, accuracy, selfie?: file }.

If online → backend will return success or rejection (strict mode). Display friendly messages.

If offline or network error → save a pending record to IndexedDB queue and mark UI as Pending Sync. The button should change to indicate pending.

Strict GPS behavior: when online, backend will reject if outside geo_radius — show exact reason & distance and do not accept clock-in. When offline, allow entry but flag as PENDING_REVIEW (clear UX that it will be reviewed and may be rejected).

3. Offline handling & Sync

Use IndexedDB (localForage or idb) to queue pending actions (clock-in/out, incident reports).

Register a service worker (vite-plugin-pwa or Workbox) to enable background sync where possible.

Implement a visible Pending Sync screen listing queued events with status and timestamp.

When app regains connectivity, auto-attempt to sync queued items in FIFO order; handle conflicts and server rejections; notify user of result.

For offline roster viewing: cache today’s and upcoming 3 days’ roster for read-only offline use.

4. Roster / Schedule screens

Today card and Upcoming list (next 7 days).

Detail screen for a shift: site, contact, instructions, PPE checklist, assigned assets.

Tapping site opens map with radius and directions link (open in Google Maps).

5. Attendance history

List of past clock-ins/outs, verification state (VERIFIED / PENDING / REJECTED), distance, photos.

Each record shows map pin and raw initData (for audit) if user taps details.

6. Incident reporting

Form: { type, description, site (optional), images[] }.

Use <input type="file" accept="image/*" capture="environment" multiple> for camera capture on mobile.

Compress images client-side (use browser-image-compression) before upload.

Support offline create (queue and sync later).

On submit (online), POST /api/incidents as multipart/form-data; show success & incident id.

7. Asset acknowledgment

Simple list of assigned assets with checkboxes: user confirms "I received" with timestamp & optional photo.

POST /api/assets/acknowledge with asset ids and selfie/photo proof if requested.

8. Payroll / Payslip view

List pay periods and downloadable payslip PDF (from backend).

Quick summary: gross, deductions (pension, tax), net pay, penalties, bonuses.

Allow download & open inside app.

9. Panic / SOS

Prominent red panic button in top/bottom toolbar.

On click open confirm modal: Pressing sends immediate POST /api/panic with current GPS and user details; also triggers Telegram notification via backend. Show local confirmation and store event locally if offline and sync later (but also attempt immediate network).

10. Profile & Settings

View/edit profile (name, phone, emergency contact).

Change password.

Language switch (English / Amharic).

Toggle optional selfie-on-clockin.

Logout (clears local data + queued items? keep queued to allow HR to sync? Decide: keep queue but mark as belonging to user).

11. Notifications

Use Web Push / Notifications API (optional) for in-app notifications.

Also rely on Telegram notifications via backend (user will receive both).

In-app notification center lists recent alerts (clock-in rejections, payroll, incidents).

GPS & Verification details (required)

Client-side helper:

Attempt navigator.geolocation.getCurrentPosition with highAccuracy true; request multiple samples until acceptable accuracy (e.g., accuracy <= 30m) or timeout 8s.

Compute Haversine distance for showing distance to user before calling API.

Server-side strict validation:

Backend returns { withinRadius: boolean, distanceMeters, reason }. If withinRadius=false and online → show message and do not record local success.

Offline flow:

Store lat/lng + accuracy + timestamp + locationMethod="client" + deviceInfo in queued record.

On sync, backend will validate; if rejected the record becomes REJECTED and notify user with reason.

UX / Visual Design (must match company tone)

Look & feel: Telegram-native look & feel but modern, clear, and mobile-first. Use clean cards, bold primary CTA, and Telegram-like color accents.

Color tokens (from staff website):

--color-primary: #0B3D91 (deep indigo)

--color-accent: #0FA3A3 (teal)

--color-warning: #FFB020

--color-bg: #F8FAFC

--color-text: #0F1724

--color-error: #D92D20

Font: Inter variable for UI; Roboto Mono for numeric tables if needed.

Buttons: Big circular/rounded primary CTA for Clock In/Out (≥56px), clear secondary actions.

Language: All UI strings via i18next; provide sample translations for English and Amharic (skeleton).

Accessibility: All interactive elements keyboard reachable, labels, alt text, color contrast.

Tech stack & libraries (strict)

Vite + React + TypeScript

Tailwind CSS for styling (with custom tokens)

react-router v6

react-query (TanStack Query) for server state

axios for HTTP with interceptors (auth + retries)

react-hook-form + zod for form validation

localForage or idb for IndexedDB queue

vite-plugin-pwa or Workbox for service worker and background sync

browser-image-compression for photo compression

Leaflet for map preview (or Mapbox token optional)

i18next for translations

Jest + React Testing Library for unit tests

Cypress for E2E tests

Storybook for UI components

API contract (expected endpoints & payloads)

(Use these when wiring up fetch hooks. Use OpenAPI if available.)

POST /api/auth/login → { phone, password } returns { access_token, refresh_token, user, expires_in }

POST /api/auth/refresh → refresh access token

GET /api/my-roster → returns upcoming shifts (today + next 7 days)

POST /api/attendance/clock-in → multipart/form-data { schedule_id, latitude, longitude, accuracy, selfie? } → returns verification result { withinRadius, distanceMeters, status, message }

POST /api/attendance/clock-out → same payload as clock-in

POST /api/attendance/sync → accept queued items batch when offline sync

GET /api/attendance/my-logs → list of past logs

POST /api/incidents → multipart { site_id?, description, images[] }

POST /api/assets/acknowledge → { asset_ids[], photos? }

GET /api/finance/my-payslips → list + links to PDFs

POST /api/panic → { latitude, longitude, note? }

GET /api/config → get geo_radius default, selfie_required flag, translations (if provided by backend)

Make sure to handle server-side validation errors and display user-friendly messages.

Offline sync & data model (implementation)

IndexedDB tables:

queued_attendance (id, schedule_id, lat, lng, accuracy, timestamp, selfie_path, status)

queued_incidents

cached_roster (today + next 7 days)

user_profile

Sync worker:

On network restored, process queues: attempt send, if succeeded remove from queue; if failed due to validation (e.g., outside radius), mark as REJECTED and notify user.

UI queue monitor:

Screen showing counts: Pending / Synced / Rejected with manual retry button.

Security & privacy

Use HTTPS always.

Minimize sensitive data persisted locally; rotate tokens regularly.

Use refresh tokens with secure cookie if possible.

For selfies/images store only temporary local path before upload; once uploaded, remove local cached copy.

Provide clear privacy text in profile settings explaining how location data is used and stored.

Tests & CI

Unit tests: auth flows, gps helper (haversine), offline queue logic.

Integration tests: simulate offline queue + network restore.

Cypress E2E: Login → Today screen → Clock-in (mock success) → create incident (mock offline & sync) → Payslip download.

GitHub Actions: lint → tests → build.

Deliverables (exact)

Full Vite React TypeScript repo: source, scripts, and configuration.

README.md with Windows 11 WSL2 dev steps, environment variables, and deploy-to-URL steps (how to point Telegram bot to it).

TASKS.md acceptance checklist for QA.

Storybook for components.

Unit & E2E tests and GitHub Actions CI config.

/design folder: mobile-first wireframes (PNG/SVG) for each major screen (Home, Clock In, Shift Detail, Attendance History, Incident Form, Payslip), color tokens file, and a small architecture diagram of offline sync.

Example .env.example with VITE_API_URL, VITE_MAPBOX_KEY (optional), VITE_APP_NAME.

Example mocks for local dev (MSW) to allow UI dev without backend.

Acceptance Criteria (when generator finishes)

App boots: npm install && npm run dev and loads on mobile viewport without console errors.

Login (phone/password) persists session; app reload restores user without re-login.

Clock-in flow works: online success/reject messages, offline queues pending and sync on reconnect.

Incident form accepts camera photos; offline incident queued and syncs later.

Map shows site marker & radius; distance display is accurate (Haversine validated).

Payslip list shows and PDFs open.

Panic button triggers a network request (or queues if offline) and shows confirmation.

i18n works for English + Amharic skeleton (switch language toggles texts).

Tests pass locally and CI config is present.